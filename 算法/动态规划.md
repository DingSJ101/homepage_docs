---
date: 2023-09-28 13:11:47.282858
lastmod: 2023-10-07 18:04:52.771543
---
# Dynamic Programming

------

## 任务安排

给定一系列任务的开始时间和结束时间，以及任务的权重，要求选择一个不冲突的任务序列，总权重最大

### 思路

考虑动规，以排序（结束时间）后任务下标做状态，`dp[n][0/1]` 。

考虑`dp[i+1][0]和dp[i+1][1]`

1. `dp[i+1][0] = max(dp[i][0],dp[i][1])`
2. `dp[i+1][1] = ?`

> ###  如果不冲突
>
> `dp[i+1][1] = max(dp[i][0],dp[i][1]) `
>
> ### 如果冲突
>
> 最后一个不冲突任务 `j` ，则必须踢掉任务`i`加上任务`i+1`
>
> `dp[i+1][1] = max(dp[j][0],dp[j][1])+w[i+1]`

### 形式化方法

对任务序列按照结束时间排序，定义`OPT(j)`表示考虑到任务`j`后的最优解 和 辅助函数$f(j)$表示与任务`j`不冲突的最后任务`i,i<j`

则$OPT(j)=\begin{cases}0 &,j=0 \\max(OPT(j-1),w_j+OPT(f(j))&,otherwize\end{cases}$

------

## 分段最小方差

给定x坐标递增二维点，使用`L`条线段分段拟合这些点，最小化损失`Cost = E+cL`其中E为分段拟合方差和，c为常数

![image-20230928151735056](https://raw.githubusercontent.com/DingSJ101/picgo_hub/main/img/20230928151737.png)

定义`OPT(j)`为考虑点`j`后的最优解，`e(i,j)`为使用一条线段拟合区间[i,j]内点的方差

$OPT(j)=\begin{cases}0 &,j=0 \\\min\limits_{1\le i\le j}(OPT(i-1)+c+e(i,j))&,otherwize\end{cases}$

## 背包问题

------

##  最长递增子序列长度（Longest Increasing Sequence,LIS）

给定一个序列，求最长的递增子序列（子序列：序列删除任意个元素后剩余的序列）长度。

### 思路

考虑依次加入序列元素，加入的元素如果参与组成最长子序列（`dp[k][1]`），则遍历之前的所有`dp[i][1]`且`a[i]<a[k]`的结果取最大值+1 ，如果不参与组成子序列则有`dp[i][0] = max{dp[i-1][0],dp[i-1][1]}`。结果为`max{dp[n][1],dp[n][0]}`。

| idx        | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| arr        | null | 4    | 1    | 3    | 7    | 9    | 4    | 5    | 6    | 7    | 2    |
| `dp[i][0]` | 0    | 0    | 1    | 1    | 2    | 3    | 4    | 4    | 4    | 5    | 6    |
| `dp[i][1]` | 0    | 1    | 1    | 2    | 3    | 4    | 3    | 4    | 5    | 6    | 6    |
| tails      | 0    |      |      |      |      |      |      |      |      |      |      |
|            | 1    | 4    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
|            | 2    |      |      | 3    | 3    | 3    | 3    | 3    | 3    | 3    | 2    |
|            | 3    |      |      |      | 7    | 7    | 4    | 4    | 4    | 4    | 4    |
|            | 4    |      |      |      |      | 9    | 9    | 5    | 5    | 5    | 5    |
|            | 5    |      |      |      |      |      |      |      | 6    | 6    | 6    |
|            | 6    |      |      |      |      |      |      |      |      | 7    | 7    |
|            | 7    |      |      |      |      |      |      |      |      |      |      |
|            | 8    |      |      |      |      |      |      |      |      |      |      |
|            | 9    |      |      |      |      |      |      |      |      |      |      |
|            | 10   |      |      |      |      |      |      |      |      |      |      |

由于`dp[i][0]`一定来源于之前的`dp[j][1]`因此可以压缩状态为`dp[i]`表示考虑前`i`个元素时的最大值。`dp[i] = max{ 1 , dp[j]+1 } for j<i`

时间复杂度为`O(n^2)` 

![在这里插入图片描述](https://raw.githubusercontent.com/DingSJ101/picgo_hub/main/img/20231007163453.png)

贪心，字典序最小的LIS中的每k个元素，都是所有长度为k的LIS结尾元素中最小的。

因此，维护长度为k的LIS的最小结尾`tail[k]`，每次进来一个新元素，因为它在已经维护的tail后面，因此二分找到它在tail中的位置，如果当前位置的元素比它小，说明在当前长度上，使用它替换后字典序更小，例子见上表。

## Code 

```C++
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 100010;
int a[N],tails[N];
int n;
int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);
    int len = 0;//记录长度
    for (int i = 0; i < n; i ++ )
    {
        int l = 0, r = len;
        while (l < r)
        {
            int mid = l + r + 1 >> 1;
            if (tails[mid] < a[i]) l = mid;
            else r = mid - 1;
        }
        //如果该元素插在了末尾，说明r+1=len+1了。此时长度增加，我们更新len 
        len = max(len, r + 1);
        tails[r + 1] = a[i];
    }
    printf("%d\n", len);
    return 0;
}

```

